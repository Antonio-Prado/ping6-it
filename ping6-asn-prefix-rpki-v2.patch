--- a/functions/api/asn/[asn].js
+++ b/functions/api/asn/[asn].js
@@ -1,5 +1,6 @@
 const RIPESTAT_AS_OVERVIEW = "https://stat.ripe.net/data/as-overview/data.json";
-
+const RIPESTAT_ANNOUNCED_PREFIXES = "https://stat.ripe.net/data/announced-prefixes/data.json";
+const RIPESTAT_RPKI_VALIDATION = "https://stat.ripe.net/data/rpki-validation/data.json";
 // Server-side caching (prefer KV if available; fallback to the Cloudflare Cache API).
 // KV binding name (recommended): ASN_META_KV
 const ASN_META_TTL_FRESH_SECONDS = 24 * 60 * 60;
@@ -109,7 +110,7 @@
   };
 }
 
-async function fetchRipestat(asn) {
+async function fetchRipestatAsOverview(asn) {
   const upstream = new URL(RIPESTAT_AS_OVERVIEW);
   upstream.searchParams.set("resource", asn);
 
@@ -139,12 +140,177 @@
           resource: block?.resource ?? null,
         }
       : null,
-    source: "ripestat-as-overview",
+  };
+}
+
+function isV6Prefix(prefix) {
+  return typeof prefix === "string" && prefix.includes(":");
+}
+
+async function fetchRipestatAnnouncedPrefixes(asn, { minPeersSeeing = 0, lookbackDays = 30 } = {}) {
+  const upstream = new URL(RIPESTAT_ANNOUNCED_PREFIXES);
+  upstream.searchParams.set("resource", `AS${asn}`);
+  upstream.searchParams.set("min_peers_seeing", String(minPeersSeeing));
+  // RIPEstat does not expose a universal lookback parameter for this dataset; we keep the value
+  // for UI/telemetry consistency.
+
+  const resp = await fetch(upstream.toString(), {
+    method: "GET",
+    headers: { accept: "application/json" },
+  });
+
+  if (!resp.ok) {
+    const err = new Error("RIPEstat announced-prefixes returned an error");
+    err.status = resp.status;
+    throw err;
+  }
+
+  const body = await resp.json();
+  const prefixes = Array.isArray(body?.data?.prefixes) ? body.data.prefixes : [];
+
+  let v4 = 0;
+  let v6 = 0;
+  const sampleV4 = [];
+  const sampleV6 = [];
+
+  for (const item of prefixes) {
+    const pfx = typeof item?.prefix === "string" ? item.prefix : null;
+    if (!pfx) continue;
+    if (isV6Prefix(pfx)) {
+      v6 += 1;
+      if (sampleV6.length < 10) sampleV6.push(pfx);
+    } else {
+      v4 += 1;
+      if (sampleV4.length < 10) sampleV4.push(pfx);
+    }
+  }
+
+  return {
+    v4,
+    v6,
+    total: v4 + v6,
+    lookbackDays,
+    minPeersSeeing,
+    samples: { v4: sampleV4, v6: sampleV6 },
+  };
+}
+
+function normalizeRpkiValidity(x) {
+  const s = String(x ?? "").toLowerCase().trim();
+  if (s === "valid") return "valid";
+  if (s === "invalid") return "invalid";
+  // Common alternative labels / shapes
+  if (s.includes("not") && s.includes("found")) return "unknown";
+  if (s === "unknown") return "unknown";
+  if (s === "unverified") return "unknown";
+  return "unknown";
+}
+
+async function fetchRipestatRpkiValidity(asn, prefix) {
+  const upstream = new URL(RIPESTAT_RPKI_VALIDATION);
+  upstream.searchParams.set("resource", `AS${asn}`);
+  upstream.searchParams.set("prefix", prefix);
+
+  const resp = await fetch(upstream.toString(), {
+    method: "GET",
+    headers: { accept: "application/json" },
+  });
+
+  if (!resp.ok) {
+    const err = new Error("RIPEstat rpki-validation returned an error");
+    err.status = resp.status;
+    throw err;
+  }
+
+  const body = await resp.json();
+  const data = body?.data;
+
+  // Different RIPEstat deployments have used slightly different shapes.
+  const validity =
+    (typeof data?.validity === "string" && data.validity) ||
+    (typeof data?.validity?.state === "string" && data.validity.state) ||
+    (typeof data?.validity?.status === "string" && data.validity.status) ||
+    (typeof data?.status === "string" && data.status) ||
+    null;
+
+  return {
+    prefix,
+    af: isV6Prefix(prefix) ? "v6" : "v4",
+    validity: normalizeRpkiValidity(validity),
+  };
+}
+
+async function mapLimit(items, limit, fn) {
+  const arr = Array.isArray(items) ? items : [];
+  const out = new Array(arr.length);
+  let i = 0;
+
+  async function worker() {
+    while (true) {
+      const idx = i;
+      i += 1;
+      if (idx >= arr.length) return;
+      out[idx] = await fn(arr[idx], idx);
+    }
+  }
+
+  const workers = new Array(Math.min(limit, arr.length)).fill(0).map(worker);
+  await Promise.all(workers);
+  return out;
+}
+
+function emptyRpkiCounts() {
+  return { valid: 0, invalid: 0, unknown: 0, total: 0 };
+}
+
+function bumpCounts(counts, validity) {
+  const k = validity === "valid" ? "valid" : validity === "invalid" ? "invalid" : "unknown";
+  counts[k] += 1;
+  counts.total += 1;
+}
+
+async function buildAsnMeta(asn) {
+  const [overview, prefixes] = await Promise.all([
+    fetchRipestatAsOverview(asn),
+    fetchRipestatAnnouncedPrefixes(asn).catch(() => null),
+  ]);
+
+  let rpkiSample = null;
+  if (prefixes && (prefixes.samples.v4.length || prefixes.samples.v6.length)) {
+    const sample = [...prefixes.samples.v4.slice(0, 10), ...prefixes.samples.v6.slice(0, 10)];
+    try {
+      const items = await mapLimit(sample, 4, (pfx) => fetchRipestatRpkiValidity(asn, pfx));
+      const v4 = emptyRpkiCounts();
+      const v6 = emptyRpkiCounts();
+      const total = emptyRpkiCounts();
+
+      for (const it of items) {
+        if (!it) continue;
+        bumpCounts(total, it.validity);
+        if (it.af === "v6") bumpCounts(v6, it.validity);
+        else bumpCounts(v4, it.validity);
+      }
+
+      rpkiSample = {
+        counts: { v4, v6, total },
+        sampled: { v4: prefixes.samples.v4.slice(0, 10).length, v6: prefixes.samples.v6.slice(0, 10).length },
+        samples: items.filter(Boolean),
+      };
+    } catch {
+      rpkiSample = { error: true };
+    }
+  }
+
+  return {
+    ...overview,
+    announcedPrefixes: prefixes,
+    rpkiSample,
+    source: "ripestat-as-overview+announced-prefixes+rpki-validation",
   };
 }
 
 async function refreshRecord({ kv, cache, asn }) {
-  const payload = await fetchRipestat(asn);
+  const payload = await buildAsnMeta(asn);
   const record = { fetchedAt: Date.now(), payload };
   await Promise.all([writeToKv(kv, asn, record), writeToEdgeCache(cache, asn, record)]);
   return record;
@@ -185,7 +351,7 @@
   // 3) Cache miss: fetch now.
   let payload;
   try {
-    payload = await fetchRipestat(asn);
+    payload = await buildAsnMeta(asn);
   } catch {
     return json({ error: "upstream_error", message: "RIPEstat request failed." }, 502, "no-store");
   }

--- a/src/App.jsx
+++ b/src/App.jsx
@@ -293,6 +293,17 @@
     asnMetaRegistry: "Registry",
     asnMetaIana: "IANA block",
     asnMetaAnnounced: "Announced",
+    asnMetaPrefixesTitle: "Announced prefixes",
+    asnMetaPrefixesTotal: "total",
+    asnMetaPrefixesV4: "v4",
+    asnMetaPrefixesV6: "v6",
+    asnMetaPrefixesNote: ({ lookbackDays, minPeersSeeing }) => `Based on RIPEstat announced-prefixes (lookback ${lookbackDays}d, min_peers_seeing=${minPeersSeeing}).`,
+    asnMetaRpkiTitle: "RPKI validation (sample)",
+    asnMetaRpkiValid: "valid",
+    asnMetaRpkiInvalid: "invalid",
+    asnMetaRpkiUnknown: "unknown",
+    asnMetaRpkiUnavailable: "RPKI sample unavailable.",
+    asnMetaRpkiNote: ({ nV4, nV6 }) => `Sampled ${nV4} IPv4 + ${nV6} IPv6 prefix(es) from announced prefixes.`,
     asnMetaProvenance: ({ source, cache, age, fetchedAt }) => {
       const parts = [];
       if (source) parts.push(`source: ${source}`);
@@ -4229,6 +4240,70 @@
                 );
               })()}
 
+              {(() => {
+                const meta = asnCard.meta;
+                const pfx = meta?.announcedPrefixes;
+                const rpki = meta?.rpkiSample;
+                if (!pfx) return null;
+
+                return (
+                  <div style={{ marginTop: 10, display: 'grid', gridTemplateColumns: 'minmax(0,1fr) minmax(0,1fr)', gap: 10, fontSize: 13 }}>
+                    <div style={{ padding: 10, border: '1px solid #e5e7eb', borderRadius: 12 }}>
+                      <div style={{ fontWeight: 800, marginBottom: 6 }}>{t('asnMetaPrefixesTitle')}</div>
+                      <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
+                        <div><span style={{ fontWeight: 700 }}>{t('asnMetaPrefixesTotal')}:</span> {pfx.total}</div>
+                        <div><span style={{ fontWeight: 700 }}>{t('asnMetaPrefixesV4')}:</span> {pfx.v4}</div>
+                        <div><span style={{ fontWeight: 700 }}>{t('asnMetaPrefixesV6')}:</span> {pfx.v6}</div>
+                      </div>
+                      <div style={{ marginTop: 6, fontSize: 12, opacity: 0.75 }}>
+                        {t('asnMetaPrefixesNote', { lookbackDays: pfx.lookbackDays, minPeersSeeing: pfx.minPeersSeeing })}
+                      </div>
+                    </div>
+
+                    <div style={{ padding: 10, border: '1px solid #e5e7eb', borderRadius: 12 }}>
+                      <div style={{ fontWeight: 800, marginBottom: 6 }}>{t('asnMetaRpkiTitle')}</div>
+                      {rpki?.counts?.total ? (
+                        <>
+                          <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
+                            <div><span style={{ fontWeight: 700 }}>{t('asnMetaRpkiValid')}:</span> {rpki.counts.total.valid}</div>
+                            <div><span style={{ fontWeight: 700 }}>{t('asnMetaRpkiInvalid')}:</span> {rpki.counts.total.invalid}</div>
+                            <div><span style={{ fontWeight: 700 }}>{t('asnMetaRpkiUnknown')}:</span> {rpki.counts.total.unknown}</div>
+                            <div><span style={{ fontWeight: 700 }}>n:</span> {rpki.counts.total.total}</div>
+                          </div>
+                          <div style={{ marginTop: 6, fontSize: 12, opacity: 0.75 }}>
+                            {t('asnMetaRpkiNote', { nV4: rpki.sampled?.v4 ?? 0, nV6: rpki.sampled?.v6 ?? 0 })}
+                          </div>
+                          {Array.isArray(rpki.samples) && rpki.samples.length ? (
+                            <div style={{ marginTop: 8, fontSize: 12 }}>
+                              <table style={{ borderCollapse: 'collapse', width: '100%' }}>
+                                <thead>
+                                  <tr>
+                                    {['prefix', 'af', 'validity'].map((h) => (
+                                      <th key={h} style={{ textAlign: 'left', borderBottom: '1px solid #e5e7eb', padding: '4px 6px' }}>{h}</th>
+                                    ))}
+                                  </tr>
+                                </thead>
+                                <tbody>
+                                  {rpki.samples.slice(0, 8).map((it, i) => (
+                                    <tr key={it.prefix || i}>
+                                      <td style={{ padding: '4px 6px', borderBottom: '1px solid #f3f4f6' }}>{it.prefix}</td>
+                                      <td style={{ padding: '4px 6px', borderBottom: '1px solid #f3f4f6' }}>{it.af}</td>
+                                      <td style={{ padding: '4px 6px', borderBottom: '1px solid #f3f4f6' }}>{it.validity}</td>
+                                    </tr>
+                                  ))}
+                                </tbody>
+                              </table>
+                            </div>
+                          ) : null}
+                        </>
+                      ) : (
+                        <div style={{ fontSize: 12, opacity: 0.75 }}>{t('asnMetaRpkiUnavailable')}</div>
+                      )}
+                    </div>
+                  </div>
+                );
+              })()}
+
               <div style={{ marginTop: 12, display: 'grid', gridTemplateColumns: 'minmax(0,1fr) minmax(0,1fr) minmax(0,1fr)', gap: 10, fontSize: 13 }}>
                 <div style={{ padding: 10, border: '1px solid #e5e7eb', borderRadius: 12 }}>
                   <div style={{ fontWeight: 800, marginBottom: 6 }}>Median v4</div>
