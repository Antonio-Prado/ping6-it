diff --git a/functions/api/atlas/measurements-pair.js b/functions/api/atlas/measurements-pair.js
index a4dcd56..a0fb4d3 100644
--- a/functions/api/atlas/measurements-pair.js
+++ b/functions/api/atlas/measurements-pair.js
@@ -287,6 +287,7 @@ async function atlasPost(path, payload, apiKey, signal) {
   if (!res.ok) {
     const err = new Error("Atlas upstream error");
     err.status = res.status;
+    err.retryAfter = res.headers.get("retry-after") || undefined;
     err.data = data;
     throw err;
   }
@@ -377,6 +378,7 @@ export async function onRequestPost(context) {
       {
         error: "atlas_failed",
         status: e.status || 500,
+        retryAfter: e.retryAfter || undefined,
         details: e.data || {},
       },
       e.status || 500
diff --git a/functions/api/measurements-pair.js b/functions/api/measurements-pair.js
index 8e42beb..4328c86 100644
--- a/functions/api/measurements-pair.js
+++ b/functions/api/measurements-pair.js
@@ -33,6 +33,7 @@ async function postJson(url, payload, signal) {
   if (!res.ok) {
     const err = new Error("Upstream error");
     err.status = res.status;
+    err.retryAfter = res.headers.get("retry-after") || undefined;
     err.data = data;
     throw err;
   }
@@ -140,6 +141,6 @@ export async function onRequestPost(context) {
 
     return json({ m4, m6 });
   } catch (e) {
-    return json({ error: "globalping_failed", status: e.status || 500, details: e.data || {} }, e.status || 500);
+    return json({ error: "globalping_failed", status: e.status || 500, retryAfter: e.retryAfter || undefined, details: e.data || {} }, e.status || 500);
   }
 }
diff --git a/src/App.jsx b/src/App.jsx
index 1f2dacb..bb69ce8 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -293,6 +293,16 @@ const COPY = {
     errorHumanVerification: "Human verification failed. Please retry.",
     errorHumanVerificationTimeout: "Human verification timed out. Please retry.",
     errorRequestFailed: ({ status }) => `Request failed (${status})`,
+    errorRateLimited: ({ retryAfter }) =>
+      `Too many requests (rate limit). Please wait${retryAfter ? ` ${retryAfter}` : ""} and try again.`,
+    errorUpstreamUnavailable: "The measurement service is temporarily unavailable. Please retry in a moment.",
+    errorNetworkFailure: "Network error. Please check your connection and retry.",
+    errorTurnstileChallengeFailed: ({ code }) =>
+      `Human verification failed (Turnstile error ${code}). Try refreshing the page, disabling blockers/VPN, or switching browser/network.`,
+    errorTurnstileConfig: ({ code }) =>
+      `Human verification is misconfigured (Turnstile error ${code}). Please contact the site owner.`,
+    errorTurnstileNetwork: ({ code }) =>
+      `Human verification could not load (Turnstile error ${code}). Please check your connection and disable blockers, then retry.`,
   },
 };
 
@@ -1229,7 +1239,22 @@ export default function App() {
           if (!pending || pending.done) return;
           pending.done = true;
           pending.cleanup();
-          pending.reject(new Error(`Turnstile error: ${code || "unknown"}`));
+
+          const raw = code ?? "unknown";
+          const n = Number(raw);
+          const family = Number.isFinite(n) ? Math.floor(n / 1000) : null;
+
+          let msg;
+          if (family === 600 || family === 300) msg = t("errorTurnstileChallengeFailed", { code: raw });
+          else if (family === 110 || family === 400) msg = t("errorTurnstileConfig", { code: raw });
+          else if (family === 120 || family === 102 || family === 103 || family === 104 || family === 106)
+            msg = t("errorTurnstileNetwork", { code: raw });
+          else msg = t("errorTurnstileChallengeFailed", { code: raw });
+
+          const err = new Error(msg);
+          err.kind = "turnstile";
+          err.turnstileCode = raw;
+          pending.reject(err);
         },
         "expired-callback": () => {
           const pending = turnstilePendingRef.current;
@@ -1283,6 +1308,123 @@ export default function App() {
     });
   }
 
+  function formatRetryAfterHeader(value) {
+    const s = String(value || "").trim();
+    if (!s) return "";
+
+    const n = Number(s);
+    if (Number.isFinite(n) && n > 0) return `${Math.round(n)}s`;
+
+    const d = Date.parse(s);
+    if (!Number.isNaN(d)) {
+      const delta = Math.round((d - Date.now()) / 1000);
+      if (Number.isFinite(delta) && delta > 0) return `${delta}s`;
+    }
+
+    return s;
+  }
+
+  function formatParamsList(params) {
+    if (!params || typeof params !== "object") return "";
+    const entries = Object.entries(params)
+      .map(([k, v]) => [String(k), typeof v === "string" ? v : JSON.stringify(v)])
+      .filter(([k, v]) => k && v);
+
+    if (!entries.length) return "";
+    return entries.map(([k, v]) => `- ${k}: ${v}`).join("\n");
+  }
+
+  function buildPairErrorMessage({ status, data, retryAfter }) {
+    const retry = formatRetryAfterHeader(retryAfter || data?.retryAfter);
+    const code = data?.error;
+
+    if (status === 429) {
+      return t("errorRateLimited", { retryAfter: retry });
+    }
+
+    if (code === "turnstile_failed") {
+      const codes = Array.isArray(data?.codes) ? data.codes.filter(Boolean) : [];
+      return codes.length ? `${t("errorHumanVerification")}
+Codes: ${codes.join(", ")}` : t("errorHumanVerification");
+    }
+
+    if (code === "turnstile_bad_action" || code === "turnstile_bad_hostname") {
+      return t("errorTurnstileConfig", { code: "server" });
+    }
+
+    if (code === "missing_atlas_api_key") {
+      return "RIPE Atlas needs an API key. Paste it in the Settings panel and retry.";
+    }
+
+    if (code === "invalid_json" || code === "missing_fields") {
+      return t("errorUpstreamUnavailable");
+    }
+
+    if (code === "invalid_target" || code === "invalid_type" || code === "invalid_flow" || code === "unsupported_type") {
+      return "Invalid request. Please review your input and retry.";
+    }
+
+    if (code === "globalping_failed") {
+      const upstream = data?.details || {};
+      const isValidation = upstream?.error?.type === "validation_error";
+      const header = isValidation
+        ? `Globalping rejected the request (${data?.status || status})`
+        : `Globalping failed (${data?.status || status})`;
+      const detailMsg =
+        upstream?.error?.message || upstream?.error?.type || upstream?.message || upstream?.error || upstream?.raw || "";
+
+      const paramLines = formatParamsList(upstream?.error?.params);
+      const pieces = [header];
+      if (detailMsg) pieces.push(String(detailMsg));
+      if (paramLines) pieces.push(paramLines);
+      return pieces.join("\n");
+    }
+
+    if (code === "atlas_failed") {
+      const upstream = data?.details || {};
+      const header = `RIPE Atlas failed (${data?.status || status})`;
+      const detailMsg = upstream?.message || upstream?.error || upstream?.raw || "";
+      const pieces = [header];
+      if (detailMsg) pieces.push(String(detailMsg));
+      return pieces.join("\n");
+    }
+
+    // Generic fallbacks.
+    if (status >= 500) return t("errorUpstreamUnavailable");
+    return code || t("errorRequestFailed", { status });
+  }
+
+  function toUserFacingError(e) {
+    if (!e) return t("errorUpstreamUnavailable");
+
+    // AbortController / fetch abort.
+    if (e.name === "AbortError" || e.message === "Aborted") {
+      return t("errorCancelled");
+    }
+
+    // Our API errors (createMeasurementsPair).
+    if (e.kind === "api" && typeof e.message === "string" && e.message) {
+      return e.message;
+    }
+
+    // Globalping/Atlas polling errors.
+    const status = e.status;
+    if (status === 429) {
+      return t("errorRateLimited", { retryAfter: formatRetryAfterHeader(e.retryAfter) });
+    }
+
+    if (status && status >= 500) {
+      return t("errorUpstreamUnavailable");
+    }
+
+    // Typical fetch network errors.
+    if (e instanceof TypeError && String(e.message || "").toLowerCase().includes("fetch")) {
+      return t("errorNetworkFailure");
+    }
+
+    return e.message || String(e);
+  }
+
   async function createMeasurementsPair({ turnstileToken, base, measurementOptions, flow }, signal) {
     const url = backend === "atlas" ? "/api/atlas/measurements-pair" : "/api/measurements-pair";
     const headers = { "content-type": "application/json" };
@@ -1305,11 +1447,13 @@ export default function App() {
     }
 
     if (!res.ok) {
-      const msg =
-        data?.error === "turnstile_failed"
-          ? t("errorHumanVerification")
-          : data?.error || t("errorRequestFailed", { status: res.status });
+      const retryAfter = res.headers.get("retry-after") || undefined;
+      const msg = buildPairErrorMessage({ status: res.status, data, retryAfter });
       const err = new Error(msg);
+      err.kind = "api";
+      err.status = res.status;
+      err.code = data?.error;
+      err.retryAfter = retryAfter || data?.retryAfter;
       err.details = data;
       throw err;
     }
@@ -1583,7 +1727,7 @@ export default function App() {
         }
       }
     } catch (e) {
-      const message = e?.message || String(e);
+      const message = toUserFacingError(e);
       if (message === t("errorCancelled") && turnstileTimedOut) {
         setErr(t("errorHumanVerificationTimeout"));
       } else {
diff --git a/src/lib/atlas.js b/src/lib/atlas.js
index 3250292..fd95bb3 100644
--- a/src/lib/atlas.js
+++ b/src/lib/atlas.js
@@ -4,6 +4,30 @@ const DEFAULT_POLL_MAX_MS = 12000;
 const DEFAULT_STABLE_POLLS = 3;
 const DEFAULT_SETTLE_AFTER_MS = 15000;
 
+async function readTextSafe(resp) {
+  try {
+    return await resp.text();
+  } catch {
+    return "";
+  }
+}
+
+function tryParseJson(text) {
+  if (!text) return null;
+  try {
+    return JSON.parse(text);
+  } catch {
+    return null;
+  }
+}
+
+function makeHttpError(message, meta) {
+  const err = new Error(message);
+  err.kind = "http";
+  if (meta && typeof meta === "object") Object.assign(err, meta);
+  return err;
+}
+
 function sleep(ms) {
   return new Promise((resolve) => setTimeout(resolve, ms));
 }
@@ -38,20 +62,26 @@ export function setStoredAtlasKey(key) {
 export async function getAtlasMeasurement(id, { signal, atlasKey } = {}) {
   const url = `/api/atlas/measurements/${encodeURIComponent(id)}`;
   const res = await fetch(url, { method: "GET", headers: buildHeaders({ atlasKey }), signal });
-  const text = await res.text();
-  let data = null;
-  try {
-    data = text ? JSON.parse(text) : null;
-  } catch {
-    // ignore
-  }
+
+  const text = await readTextSafe(res);
+  const parsed = tryParseJson(text);
+  const data = parsed !== null ? parsed : text ? { raw: text } : null;
+
   if (!res.ok) {
     const msg =
-      (data && (data.error || data.message)) ||
+      (parsed && (parsed.error || parsed.message)) ||
       (text && text.slice(0, 300)) ||
       `Atlas request failed (${res.status})`;
-    throw new Error(String(msg));
+
+    throw makeHttpError(String(msg), {
+      status: res.status,
+      url,
+      data: parsed || null,
+      text,
+      retryAfter: res.headers.get("retry-after") || undefined,
+    });
   }
+
   return data;
 }
 
diff --git a/src/lib/globalping.js b/src/lib/globalping.js
index 4d0e08a..e0b4d05 100644
--- a/src/lib/globalping.js
+++ b/src/lib/globalping.js
@@ -2,8 +2,35 @@ const API = "/api/globalping";
 
 const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
 
+async function readTextSafe(resp) {
+  try {
+    return await resp.text();
+  } catch {
+    return "";
+  }
+}
+
+function tryParseJson(text) {
+  if (!text) return null;
+  try {
+    return JSON.parse(text);
+  } catch {
+    return null;
+  }
+}
+
+function makeHttpError(message, meta) {
+  const err = new Error(message);
+  err.kind = "http";
+  if (meta && typeof meta === "object") {
+    Object.assign(err, meta);
+  }
+  return err;
+}
+
 export async function createMeasurement(body, signal) {
-  const resp = await fetch(`${API}/measurements`, {
+  const url = `${API}/measurements`;
+  const resp = await fetch(url, {
     method: "POST",
     headers: { "content-type": "application/json" },
     body: JSON.stringify(body),
@@ -11,9 +38,17 @@ export async function createMeasurement(body, signal) {
   });
 
   if (!resp.ok) {
-    const txt = await resp.text().catch(() => "");
-    throw new Error(`Globalping create failed (${resp.status}): ${txt}`);
+    const text = await readTextSafe(resp);
+    const data = tryParseJson(text) || null;
+    throw makeHttpError(`Globalping request failed (${resp.status})`, {
+      status: resp.status,
+      url,
+      data,
+      text,
+      retryAfter: resp.headers.get("retry-after") || undefined,
+    });
   }
+
   return resp.json();
 }
 
@@ -21,7 +56,8 @@ export async function getMeasurement(id, { etag, signal } = {}) {
   const headers = {};
   if (etag) headers["if-none-match"] = etag;
 
-  const resp = await fetch(`${API}/measurements/${encodeURIComponent(id)}`, {
+  const url = `${API}/measurements/${encodeURIComponent(id)}`;
+  const resp = await fetch(url, {
     method: "GET",
     headers,
     signal,
@@ -30,8 +66,15 @@ export async function getMeasurement(id, { etag, signal } = {}) {
   if (resp.status === 304) return { notModified: true, etag };
 
   if (!resp.ok) {
-    const txt = await resp.text().catch(() => "");
-    throw new Error(`Globalping get failed (${resp.status}): ${txt}`);
+    const text = await readTextSafe(resp);
+    const data = tryParseJson(text) || null;
+    throw makeHttpError(`Globalping request failed (${resp.status})`, {
+      status: resp.status,
+      url,
+      data,
+      text,
+      retryAfter: resp.headers.get("retry-after") || undefined,
+    });
   }
 
   const newEtag = resp.headers.get("etag") || undefined;
@@ -52,4 +95,3 @@ export async function waitForMeasurement(id, { onUpdate, signal } = {}) {
     await sleep(500);
   }
 }
-
