--- a/functions/api/atlas/measurements/[id].js
+++ b/functions/api/atlas/measurements/[id].js
@@ -48,6 +48,91 @@
   return Number.isFinite(n) ? n : null;
 }
 
+
+function normalizeProbeMeta(p) {
+  const id = String(p?.id ?? "").trim();
+  const countryCode = String(p?.country_code ?? "").trim();
+  const asnV6 = toNumber(p?.asn_v6);
+  const asnV4 = toNumber(p?.asn_v4);
+  const asn = asnV6 ?? asnV4 ?? undefined;
+
+  let latitude;
+  let longitude;
+  const coords = p?.geometry?.coordinates;
+  if (Array.isArray(coords) && coords.length >= 2) {
+    const lon = Number(coords[0]);
+    const lat = Number(coords[1]);
+    if (Number.isFinite(lat) && Number.isFinite(lon)) {
+      latitude = lat;
+      longitude = lon;
+    }
+  }
+
+  return {
+    id: id || undefined,
+    country: countryCode || undefined,
+    country_code: countryCode || undefined,
+    asn,
+    latitude,
+    longitude,
+  };
+}
+
+async function fetchProbeMetaMap(probeIds, apiKey, signal) {
+  const ids = Array.from(new Set((probeIds || []).map((x) => String(x).trim()).filter(Boolean)));
+  if (!ids.length) return new Map();
+
+  // Keep it bounded to avoid slow responses.
+  const MAX = 80;
+  const limited = ids.slice(0, MAX);
+
+  const fields = "id,country_code,asn_v4,asn_v6,geometry";
+
+  // Attempt a batched lookup first. If the API doesn't support the filter, we'll
+  // still fall back to per-probe lookups for the missing ids.
+  const map = new Map();
+  try {
+    const qs = new URLSearchParams({
+      id__in: limited.join(","),
+      limit: String(limited.length),
+      fields,
+    });
+    const data = await atlasGetJson(`/api/v2/probes/?${qs.toString()}`, apiKey, signal);
+    const list = Array.isArray(data?.results) ? data.results : Array.isArray(data) ? data : [];
+    for (const p of list) {
+      const meta = normalizeProbeMeta(p);
+      if (meta.id) map.set(String(meta.id), meta);
+    }
+  } catch {
+    // ignore
+  }
+
+  // Fill gaps (or fully resolve) via per-probe lookups.
+  const missing = limited.filter((pid) => !map.has(String(pid)));
+  if (!missing.length) return map;
+
+  const settled = await Promise.all(
+    missing.map(async (pid) => {
+      try {
+        const p = await atlasGetJson(
+          `/api/v2/probes/${encodeURIComponent(pid)}/?fields=${encodeURIComponent(fields)}`,
+          apiKey,
+          signal
+        );
+        return normalizeProbeMeta(p);
+      } catch {
+        return null;
+      }
+    })
+  );
+
+  for (const meta of settled) {
+    if (meta?.id) map.set(String(meta.id), meta);
+  }
+  return map;
+}
+
+
 function computePingStats(r) {
   const sent = toNumber(r?.sent) ?? (Array.isArray(r?.result) ? r.result.length : null);
   const rcvd =
@@ -183,10 +268,16 @@
 
     const rows = Array.isArray(rawResults) ? rawResults : [];
 
+    const probeMeta = await fetchProbeMetaMap(
+      rows.map((r) => r?.prb_id),
+      apiKey,
+      request.signal
+    );
+
     const normalized = rows
       .map((r) => {
         const prbId = String(r?.prb_id || "");
-        const probe = { id: prbId };
+        const probe = probeMeta.get(prbId) || { id: prbId };
         const type = String(r?.type || meta?.type || "").toLowerCase();
         if (type === "ping") return normalizePingResult(r, probe);
         if (type === "traceroute") return normalizeTracerouteResult(r, probe);

--- a/src/App.jsx
+++ b/src/App.jsx
@@ -531,10 +531,12 @@
   if (!probe) return "-";
   const city = String(probe.city ?? "").trim();
   const country = String(probe.country ?? probe.country_code ?? "").trim();
+  const id = probe.id !== undefined && probe.id !== null ? String(probe.id).trim() : "";
   if (city && country) return `${city}, ${country}`;
   if (city) return city;
+  if (country && id) return `${country} Â· Probe ${id}`;
   if (country) return country;
-  if (probe.id !== undefined && probe.id !== null) return `Probe ${probe.id}`;
+  if (id) return `Probe ${id}`;
   return "-";
 }
 
