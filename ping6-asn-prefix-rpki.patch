diff --git a/functions/api/asn/[asn].js b/functions/api/asn/[asn].js
index 135169b..4b3a6b8 100644
--- a/functions/api/asn/[asn].js
+++ b/functions/api/asn/[asn].js
@@ -1,4 +1,14 @@
 const RIPESTAT_AS_OVERVIEW = "https://stat.ripe.net/data/as-overview/data.json";
+const RIPESTAT_ANNOUNCED_PREFIXES = "https://stat.ripe.net/data/announced-prefixes/data.json";
+const RIPESTAT_RPKI_VALIDATION = "https://stat.ripe.net/data/rpki-validation/data.json";
+
+// Announced prefixes + RPKI sampling configuration.
+// Keep the returned payload small: compute counts server-side and only return a small sample.
+const PREFIX_LOOKBACK_DAYS = 30;
+const ANNOUNCED_PREFIXES_MIN_PEERS_SEEING = 0;
+const RPKI_SAMPLE_V4 = 10;
+const RPKI_SAMPLE_V6 = 10;
+const RPKI_CONCURRENCY = 4;
 
 // Server-side caching (prefer KV if available; fallback to the Cloudflare Cache API).
 // KV binding name (recommended): ASN_META_KV
@@ -109,27 +119,53 @@ function buildResponsePayload(payload, fetchedAtMs, cacheStatus) {
   };
 }
 
-async function fetchRipestat(asn) {
-  const upstream = new URL(RIPESTAT_AS_OVERVIEW);
-  upstream.searchParams.set("resource", asn);
+function isV6Prefix(pfx) {
+  return typeof pfx === "string" && pfx.includes(":");
+}
 
-  const resp = await fetch(upstream.toString(), {
-    method: "GET",
-    headers: { accept: "application/json" },
-  });
+function isV4Prefix(pfx) {
+  return typeof pfx === "string" && pfx.includes(".");
+}
+
+function addUnique(set, arr, v) {
+  if (!v) return;
+  if (set.has(v)) return;
+  set.add(v);
+  arr.push(v);
+}
 
-  if (!resp.ok) {
-    const err = new Error("RIPEstat returned an error");
-    err.status = resp.status;
-    throw err;
+async function fetchJson(url, { timeoutMs = 12000 } = {}) {
+  const ac = new AbortController();
+  const timer = setTimeout(() => ac.abort(), timeoutMs);
+
+  try {
+    const resp = await fetch(url, {
+      method: "GET",
+      headers: { accept: "application/json" },
+      signal: ac.signal,
+    });
+
+    if (!resp.ok) {
+      const err = new Error("Upstream returned an error");
+      err.status = resp.status;
+      throw err;
+    }
+
+    return await resp.json();
+  } finally {
+    clearTimeout(timer);
   }
+}
+
+async function fetchAsOverview(asn) {
+  const upstream = new URL(RIPESTAT_AS_OVERVIEW);
+  upstream.searchParams.set("resource", asn);
 
-  const body = await resp.json();
+  const body = await fetchJson(upstream.toString());
   const data = body && typeof body === "object" ? body.data : null;
   const block = data && typeof data === "object" ? data.block : null;
 
   return {
-    asn: Number(asn),
     holder: data?.holder ?? null,
     announced: typeof data?.announced === "boolean" ? data.announced : null,
     registry: block
@@ -139,6 +175,162 @@ async function fetchRipestat(asn) {
           resource: block?.resource ?? null,
         }
       : null,
+  };
+}
+
+async function fetchAnnouncedPrefixes(asn) {
+  const upstream = new URL(RIPESTAT_ANNOUNCED_PREFIXES);
+  upstream.searchParams.set("resource", asn);
+
+  const end = new Date();
+  const start = new Date(Date.now() - PREFIX_LOOKBACK_DAYS * 24 * 60 * 60 * 1000);
+  upstream.searchParams.set("starttime", start.toISOString());
+  upstream.searchParams.set("endtime", end.toISOString());
+  upstream.searchParams.set("min_peers_seeing", String(ANNOUNCED_PREFIXES_MIN_PEERS_SEEING));
+
+  const body = await fetchJson(upstream.toString(), { timeoutMs: 20000 });
+  const data = body && typeof body === "object" ? body.data : null;
+  const prefixes = Array.isArray(data?.prefixes) ? data.prefixes : [];
+
+  // Note: we do NOT return the full list to the client; only counts + sampling are kept.
+  const v4Set = new Set();
+  const v6Set = new Set();
+  const v4Arr = [];
+  const v6Arr = [];
+
+  for (const item of prefixes) {
+    const pfx = item?.prefix;
+    if (isV6Prefix(pfx)) addUnique(v6Set, v6Arr, pfx);
+    else if (isV4Prefix(pfx)) addUnique(v4Set, v4Arr, pfx);
+  }
+
+  return {
+    v4Prefixes: v4Arr,
+    v6Prefixes: v6Arr,
+    counts: {
+      v4: v4Arr.length,
+      v6: v6Arr.length,
+      total: v4Arr.length + v6Arr.length,
+    },
+    query: {
+      lookbackDays: PREFIX_LOOKBACK_DAYS,
+      minPeersSeeing: ANNOUNCED_PREFIXES_MIN_PEERS_SEEING,
+    },
+  };
+}
+
+async function fetchRpkiValidation(asn, prefix) {
+  const upstream = new URL(RIPESTAT_RPKI_VALIDATION);
+  upstream.searchParams.set("resource", asn);
+  upstream.searchParams.set("prefix", prefix);
+
+  const body = await fetchJson(upstream.toString(), { timeoutMs: 12000 });
+  const data = body && typeof body === "object" ? body.data : null;
+
+  return {
+    prefix,
+    status: data?.status ?? null,
+    description: data?.description ?? null,
+  };
+}
+
+async function mapWithConcurrency(items, concurrency, mapper) {
+  const results = new Array(items.length);
+  let i = 0;
+
+  const workers = new Array(Math.max(1, concurrency)).fill(0).map(async () => {
+    while (true) {
+      const idx = i;
+      i += 1;
+      if (idx >= items.length) return;
+      try {
+        results[idx] = await mapper(items[idx], idx);
+      } catch (e) {
+        results[idx] = { ...items[idx], status: "error", description: String(e?.message || e || "error") };
+      }
+    }
+  });
+
+  await Promise.all(workers);
+  return results;
+}
+
+function buildRpkiCounts(sampleRows) {
+  const counts = {
+    valid: 0,
+    invalid_asn: 0,
+    invalid_length: 0,
+    unknown: 0,
+    error: 0,
+    other: 0,
+  };
+
+  for (const row of sampleRows) {
+    const s = String(row?.status || "").trim();
+    if (!s) {
+      counts.other += 1;
+      continue;
+    }
+    if (s === "valid") counts.valid += 1;
+    else if (s === "invalid_asn") counts.invalid_asn += 1;
+    else if (s === "invalid_length") counts.invalid_length += 1;
+    else if (s === "unknown") counts.unknown += 1;
+    else if (s === "error") counts.error += 1;
+    else counts.other += 1;
+  }
+
+  return counts;
+}
+
+async function fetchRipestat(asn) {
+  // Mandatory block: as-overview
+  const base = await fetchAsOverview(asn);
+
+  // Optional blocks: announced-prefixes and a small RPKI sample.
+  let prefixCounts = null;
+  let rpkiSample = null;
+
+  try {
+    const announced = await fetchAnnouncedPrefixes(asn);
+
+    prefixCounts = {
+      ...announced.counts,
+      lookbackDays: announced.query.lookbackDays,
+      minPeersSeeing: announced.query.minPeersSeeing,
+    };
+
+    const sampleV4 = announced.v4Prefixes.slice(0, RPKI_SAMPLE_V4);
+    const sampleV6 = announced.v6Prefixes.slice(0, RPKI_SAMPLE_V6);
+    const prefixes = [...sampleV4, ...sampleV6];
+
+    if (prefixes.length) {
+      const sampleRows = await mapWithConcurrency(
+        prefixes.map((p) => ({ prefix: p })),
+        RPKI_CONCURRENCY,
+        async (item) => fetchRpkiValidation(asn, item.prefix)
+      );
+
+      rpkiSample = {
+        n: sampleRows.length,
+        limits: { v4: RPKI_SAMPLE_V4, v6: RPKI_SAMPLE_V6 },
+        counts: buildRpkiCounts(sampleRows),
+        sample: sampleRows
+          .map((r) => ({ prefix: r.prefix, status: r.status, description: r.description }))
+          .slice(0, RPKI_SAMPLE_V4 + RPKI_SAMPLE_V6),
+      };
+    }
+  } catch {
+    // Leave optional sections null on failure.
+  }
+
+  return {
+    asn: Number(asn),
+    holder: base.holder,
+    announced: base.announced,
+    registry: base.registry,
+    prefixCounts,
+    rpkiSample,
+    // Backward-compatible label used by the UI.
     source: "ripestat-as-overview",
   };
 }
diff --git a/src/App.jsx b/src/App.jsx
index a747123..d905e72 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -4671,6 +4671,25 @@ ${paramLines}` : header;
                   >
                     {t('asnDetailsUseFilter')}
                   </button>
+                  <button
+                    type="button"
+                    onClick={() => {
+                      const asn = normalizeAsn(asnCard.asn);
+                      if (!asn) return;
+                      setExcludedAsns((prev) => {
+                        const set = new Set((prev || []).map(normalizeAsn).filter(Boolean));
+                        if (set.has(asn)) set.delete(asn);
+                        else set.add(asn);
+                        const next = Array.from(set).sort((a, b) => a - b);
+                        setExcludedAsnsInput(next.join(", "));
+                        return next;
+                      });
+                    }}
+                    style={{ padding: '6px 10px', borderRadius: 10, border: '1px solid #e5e7eb', background: '#fff', cursor: 'pointer' }}
+                  >
+                    {excludedAsns.includes(asnCard.asn) ? t('asnDetailsInclude') : t('asnDetailsExclude')}
+                  </button>
+
                   <button
                     type="button"
                     onClick={() => setAsnCard(null)}
@@ -4690,6 +4709,29 @@ ${paramLines}` : header;
                 const registry = meta?.registry?.name || '-';
                 const announced = typeof meta?.announced === 'boolean' ? (meta.announced ? t('yes') : t('no')) : '-';
 
+                const prefixCounts = meta?.prefixCounts || null;
+                const prefixCountsLabel = prefixCounts
+                  ? t('asnMetaPrefixCounts', {
+                      v4: Number(prefixCounts.v4 || 0),
+                      v6: Number(prefixCounts.v6 || 0),
+                      total: Number(prefixCounts.total || 0),
+                    })
+                  : '-';
+                const prefixCountsInfo = prefixCounts
+                  ? `last ${Number(prefixCounts.lookbackDays || 0)}d · min peers: ${Number(prefixCounts.minPeersSeeing ?? '-')}`
+                  : null;
+
+                const rpki = meta?.rpkiSample || null;
+                const rpkiCounts = rpki?.counts || null;
+                const rpkiInvalid = rpkiCounts
+                  ? Number(rpkiCounts.invalid_asn || 0) + Number(rpkiCounts.invalid_length || 0)
+                  : null;
+                const rpkiLabel = rpkiCounts
+                  ? `${t('asnMetaRpkiValid')}: ${Number(rpkiCounts.valid || 0)} · ${t('asnMetaRpkiInvalid')}: ${rpkiInvalid} · ${t('asnMetaRpkiUnknown')}: ${Number(rpkiCounts.unknown || 0)}`
+                  : '-';
+                const rpkiHint = rpki ? t('asnMetaRpkiHint', { n: Number(rpki.n || (rpki.sample?.length || 0)) }) : null;
+
+
                 const source = (() => {
                   const s = String(meta?.source || '').trim();
                   if (s === 'ripestat-as-overview') return 'RIPEstat (as-overview)';
@@ -4730,6 +4772,29 @@ ${paramLines}` : header;
                         <div>{meta.registry.desc}</div>
                       </div>
                     ) : null}
+
+                    <div style={{ marginTop: 10, display: 'grid', gridTemplateColumns: 'minmax(0,1fr) minmax(0,1fr)', gap: 10, fontSize: 13 }}>
+                      <div style={{ padding: 10, border: '1px solid #e5e7eb', borderRadius: 12 }}>
+                        <div style={{ fontWeight: 800, marginBottom: 6 }}>{t('asnMetaAnnouncedPrefixes')}</div>
+                        <div>{prefixCountsLabel}</div>
+                        {prefixCountsInfo ? (
+                          <div style={{ marginTop: 6, fontSize: 12, opacity: 0.75 }}>{prefixCountsInfo}</div>
+                        ) : null}
+                      </div>
+                      <div style={{ padding: 10, border: '1px solid #e5e7eb', borderRadius: 12 }}>
+                        <div style={{ fontWeight: 800, marginBottom: 6 }}>{t('asnMetaRpkiSample')}</div>
+                        <div>{rpkiLabel}</div>
+                        {rpkiHint ? <div style={{ marginTop: 6, fontSize: 12, opacity: 0.75 }}>{rpkiHint}</div> : null}
+                        {rpki?.sample?.length ? (
+                          <div style={{ marginTop: 8, fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace', fontSize: 12, lineHeight: 1.35, opacity: 0.9 }}>
+                            {rpki.sample.slice(0, 8).map((r) => (
+                              <div key={r.prefix}>{r.prefix} — {String(r.status || '-')}</div>
+                            ))}
+                          </div>
+                        ) : null}
+                      </div>
+                    </div>
+
                   </>
                 );
               })()}
