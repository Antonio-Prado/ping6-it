diff --git a/functions/api/atlas/measurements/[id].js b/functions/api/atlas/measurements/[id].js
index 2a60bb3..2c368f4 100644
--- a/functions/api/atlas/measurements/[id].js
+++ b/functions/api/atlas/measurements/[id].js
@@ -47,15 +47,75 @@ async function fetchProbeMetaMap(probeIds, apiKey, signal) {
   const qs = new URLSearchParams({
     id__in: ids.join(","),
     limit: String(ids.length),
     fields: "id,country_code,asn_v4,asn_v6,asn_v4_name,asn_v6_name,geometry",
   });
 
-  const data = await atlasGetJson(`/api/v2/probes/?${qs.toString()}`, apiKey, signal);
-  const list = Array.isArray(data?.results) ? data.results : Array.isArray(data) ? data : [];
-  const map = new Map();
-  for (const p of list) {
-    const meta = normalizeProbeMeta(p);
-    if (meta.id) map.set(String(meta.id), meta);
-  }
-  return map;
+  const map = new Map();
+
+  // Best-effort cache across warm Worker instances to avoid refetching probe metadata on every poll.
+  const cache =
+    globalThis.__PING6_ATLAS_PROBE_META_CACHE ||
+    (globalThis.__PING6_ATLAS_PROBE_META_CACHE = new Map());
+
+  for (const id of ids) {
+    const cached = cache.get(id);
+    if (cached) map.set(id, cached);
+  }
+
+  // Fast path: try the list endpoint with filters.
+  // Some Atlas deployments may not honor all filters for probes; treat empty/partial results as a signal to fall back.
+  try {
+    const data = await atlasGetJson(`/api/v2/probes/?${qs.toString()}`, apiKey, signal);
+    const list = Array.isArray(data?.results) ? data.results : Array.isArray(data) ? data : [];
+    for (const p of list) {
+      const meta = normalizeProbeMeta(p);
+      if (meta.id) {
+        map.set(String(meta.id), meta);
+        cache.set(String(meta.id), meta);
+      }
+    }
+  } catch {
+    // ignore and fall back to per-probe fetches below
+  }
+
+  const missing = ids.filter((x) => !map.has(x));
+  if (!missing.length) return map;
+
+  // Keep it bounded to avoid slow responses.
+  if (missing.length > 80) return map;
+
+  const CONCURRENCY = 10;
+  let i = 0;
+  const workers = Array.from({ length: Math.min(CONCURRENCY, missing.length) }).map(async () => {
+    while (i < missing.length) {
+      const id = missing[i++];
+      try {
+        const q = new URLSearchParams({
+          fields: "id,country_code,asn_v4,asn_v6,asn_v4_name,asn_v6_name,geometry",
+        });
+        const p = await atlasGetJson(`/api/v2/probes/${encodeURIComponent(id)}/?${q.toString()}`, apiKey, signal);
+        const meta = normalizeProbeMeta(p);
+        if (meta.id) {
+          map.set(String(meta.id), meta);
+          cache.set(String(meta.id), meta);
+        }
+      } catch {
+        // ignore per-probe failures
+      }
+    }
+  });
+  await Promise.all(workers);
+
+  return map;
 }
