diff --git a/functions/api/atlas/measurements-pair.js b/functions/api/atlas/measurements-pair.js
index aa9025e..1a65d86 100644
--- a/functions/api/atlas/measurements-pair.js
+++ b/functions/api/atlas/measurements-pair.js
@@ -14,6 +14,10 @@ function json(body, status = 200) {
   });
 }
 
+function badRequest(error, message, params) {
+  return json({ error, message, params }, 400);
+}
+
 function clampInt(x, { min, max, fallback }) {
   const n = Number(x);
   if (!Number.isFinite(n)) return fallback;
@@ -309,26 +313,38 @@ export async function onRequestPost(context) {
   if (!secret) return json({ error: "TURNSTILE_SECRET not set" }, 500);
 
   const apiKey = extractAtlasKey(request, env);
-  if (!apiKey) return json({ error: "missing_atlas_api_key" }, 400);
+  if (!apiKey) return badRequest("missing_atlas_api_key", "RIPE Atlas needs an API key.", { hint: "Paste it in Settings (Atlas API key) and retry." });
 
   let body;
   try {
     body = await request.json();
   } catch {
-    return json({ error: "invalid_json" }, 400);
+    return badRequest("invalid_json", "Invalid JSON body.", { hint: "Send a JSON object with turnstileToken, base, measurementOptions, and flow." });
   }
 
   const { turnstileToken, base, measurementOptions, flow } = body || {};
-  if (!turnstileToken || !base || !measurementOptions || !flow) {
-    return json({ error: "missing_fields" }, 400);
+
+  const missing = [];
+  if (!turnstileToken) missing.push("turnstileToken");
+  if (!base) missing.push("base");
+  if (!measurementOptions) missing.push("measurementOptions");
+  if (!flow) missing.push("flow");
+  if (missing.length) {
+    return badRequest("missing_fields", `Missing required field(s): ${missing.join(", ")}.`, { missing });
   }
 
-  if (!ALLOWED_TYPES.has(base.type)) return json({ error: "unsupported_type" }, 400);
-  if (typeof base.target !== "string" || !base.target.trim()) return json({ error: "invalid_target" }, 400);
+  if (!ALLOWED_TYPES.has(base.type)) {
+    return badRequest("unsupported_type", `Unsupported measurement type for RIPE Atlas: ${String(base.type)}.`, { type: base.type, allowed: Array.from(ALLOWED_TYPES) });
+  }
+  if (typeof base.target !== "string" || !base.target.trim()) {
+    return badRequest("invalid_target", 'Invalid "target". Expected a non-empty hostname/IP/URL string.', { target: base.target });
+  }
 
   // Atlas needs a v6-first flow to enforce the same probes for v4/v6.
   // We'll still accept both values for compatibility with the current client.
-  if (flow !== "v4first" && flow !== "v6first") return json({ error: "invalid_flow" }, 400);
+  if (flow !== "v4first" && flow !== "v6first") {
+    return badRequest("invalid_flow", 'Invalid "flow". Expected "v4first" or "v6first".', { flow, allowed: ["v4first", "v6first"] });
+  }
 
   const limit = clampInt(base.limit, { min: 1, max: 50, fallback: 3 });
 
diff --git a/functions/api/measurements-pair.js b/functions/api/measurements-pair.js
index a7c2dac..d5723fc 100644
--- a/functions/api/measurements-pair.js
+++ b/functions/api/measurements-pair.js
@@ -14,6 +14,10 @@ function json(body, status = 200) {
   });
 }
 
+function badRequest(error, message, params) {
+  return json({ error, message, params }, 400);
+}
+
 async function postJson(url, payload, signal) {
   const res = await fetch(url, {
     method: "POST",
@@ -58,20 +62,31 @@ export async function onRequestPost(context) {
   try {
     body = await request.json();
   } catch {
-    return json({ error: "invalid_json" }, 400);
+    return badRequest("invalid_json", "Invalid JSON body.", { hint: "Send a JSON object with turnstileToken, base, measurementOptions, and flow." });
   }
 
   const { turnstileToken, base, measurementOptions, flow } = body || {};
-  if (!turnstileToken || !base || !measurementOptions || !flow) {
-    return json({ error: "missing_fields" }, 400);
+
+  const missing = [];
+  if (!turnstileToken) missing.push("turnstileToken");
+  if (!base) missing.push("base");
+  if (!measurementOptions) missing.push("measurementOptions");
+  if (!flow) missing.push("flow");
+  if (missing.length) {
+    return badRequest("missing_fields", `Missing required field(s): ${missing.join(", ")}.`, { missing });
   }
+
   if (flow !== "v4first" && flow !== "v6first") {
-    return json({ error: "invalid_flow" }, 400);
+    return badRequest("invalid_flow", 'Invalid "flow". Expected "v4first" or "v6first".', { flow, allowed: ["v4first", "v6first"] });
   }
 
   // Defensive validation / clamping to reduce abuse.
-  if (!ALLOWED_TYPES.has(base.type)) return json({ error: "invalid_type" }, 400);
-  if (typeof base.target !== "string" || !base.target.trim()) return json({ error: "invalid_target" }, 400);
+  if (!ALLOWED_TYPES.has(base.type)) {
+    return badRequest("invalid_type", `Unsupported measurement type: ${String(base.type)}.`, { type: base.type, allowed: Array.from(ALLOWED_TYPES) });
+  }
+  if (typeof base.target !== "string" || !base.target.trim()) {
+    return badRequest("invalid_target", 'Invalid "target". Expected a non-empty hostname/IP/URL string.', { target: base.target });
+  }
 
   const limit = Math.max(1, Math.min(10, Number(base.limit) || 3));
 
diff --git a/src/App.jsx b/src/App.jsx
index 7513109..b999f02 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -316,6 +316,7 @@ const COPY = {
     errorHumanVerification: "Human verification failed. Please retry.",
     errorHumanVerificationTimeout: "Human verification timed out. Please retry.",
     errorRequestFailed: ({ status }) => `Request failed (${status})`,
+    errorInvalidRequest: "Invalid request. Please review your input and retry.",
     errorRateLimited: ({ retryAfter }) =>
       `Too many requests (rate limit). Please wait${retryAfter ? ` ${retryAfter}` : ""} and try again.`,
     rateLimitRetryIn: ({ seconds }) => `Rate limited. Retry in ${seconds}s.`,
@@ -1402,8 +1403,11 @@ export default function App() {
     if (!e || typeof e !== "object") return null;
     return (
       retryAfterToSeconds(e.retryAfter) ||
+      retryAfterToSeconds(e.rateLimitReset) ||
       retryAfterToSeconds(e?.details?.retryAfter) ||
+      retryAfterToSeconds(e?.details?.rateLimitReset) ||
       retryAfterToSeconds(e?.data?.retryAfter) ||
+      retryAfterToSeconds(e?.data?.rateLimitReset) ||
       null
     );
   }
@@ -1449,12 +1453,18 @@ Codes: ${codes.join(", ")}` : t("errorHumanVerification");
       return "RIPE Atlas needs an API key. Paste it in the Settings panel and retry.";
     }
 
-    if (code === "invalid_json" || code === "missing_fields") {
-      return t("errorUpstreamUnavailable");
-    }
-
-    if (code === "invalid_target" || code === "invalid_type" || code === "invalid_flow" || code === "unsupported_type") {
-      return "Invalid request. Please review your input and retry.";
+    if (
+      code === "invalid_json" ||
+      code === "missing_fields" ||
+      code === "invalid_target" ||
+      code === "invalid_type" ||
+      code === "invalid_flow" ||
+      code === "unsupported_type"
+    ) {
+      const header = data?.message || t("errorInvalidRequest");
+      const paramLines = formatParamsList(data?.params);
+      return paramLines ? `${header}
+${paramLines}` : header;
     }
 
     if (code === "globalping_failed") {
@@ -1503,7 +1513,8 @@ Codes: ${codes.join(", ")}` : t("errorHumanVerification");
     // Globalping/Atlas polling errors.
     const status = e.status;
     if (status === 429) {
-      return t("errorRateLimited", { retryAfter: formatRetryAfterHeader(e.retryAfter) });
+      const ra = e.retryAfter || e.rateLimitReset || e?.details?.retryAfter || e?.details?.rateLimitReset || e?.data?.retryAfter || e?.data?.rateLimitReset;
+      return t("errorRateLimited", { retryAfter: formatRetryAfterHeader(ra) });
     }
 
     if (status && status >= 500) {
@@ -1540,13 +1551,21 @@ Codes: ${codes.join(", ")}` : t("errorHumanVerification");
     }
 
     if (!res.ok) {
-      const retryAfter = res.headers.get("retry-after") || undefined;
+      const retryAfterHeader = res.headers.get("retry-after") || "";
+      const rateLimitResetHeader = res.headers.get("x-ratelimit-reset") || "";
+      const resetSec = Number(rateLimitResetHeader);
+      const retryAfter = retryAfterHeader
+        ? retryAfterHeader
+        : Number.isFinite(resetSec) && resetSec > 0
+          ? `${Math.ceil(resetSec)}s`
+          : undefined;
       const msg = buildPairErrorMessage({ status: res.status, data, retryAfter });
       const err = new Error(msg);
       err.kind = "api";
       err.status = res.status;
       err.code = data?.error;
       err.retryAfter = retryAfter || data?.retryAfter;
+      err.rateLimitReset = rateLimitResetHeader || data?.rateLimitReset;
       err.details = data;
       throw err;
     }
